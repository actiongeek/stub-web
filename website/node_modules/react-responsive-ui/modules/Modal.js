import _Array$from from 'babel-runtime/core-js/array/from';
import _getIterator from 'babel-runtime/core-js/get-iterator';
import _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';
import classNames from 'classnames';
import ReactModal from 'react-modal';

import Button from './Button';
import Form from './Form';

// Make sure to add `.rrui__fixed-full-width` CSS class
// to all full-width `position: fixed` elements.
// Such elements must not be `width: 100%`
// but rather `width: auto` or `left: 0; right: 0;`.

var Modal = function (_PureComponent) {
	_inherits(Modal, _PureComponent);

	function Modal() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, Modal);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Modal.__proto__ || _Object$getPrototypeOf(Modal)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
			// Using a counter instead of a boolean here
			// because a new form may be mounted before the old one is unmounted.
			// (React reconciliation algorythm implementation details)
			form: 0
		}, _this.register_form = function () {
			// Using a counter instead of a boolean here
			// because a new form may be mounted before the old one is unmounted.
			// (React reconciliation algorythm implementation details)
			_this.setState(function (_ref2) {
				var form = _ref2.form;
				return { form: form + 1 };
			});
		}, _this.unregister_form = function () {
			if (_this.unmounted) {
				return;
			}

			// Using a counter instead of a boolean here
			// because a new form may be mounted before the old one is unmounted.
			// (React reconciliation algorythm implementation details)
			_this.setState(function (_ref3) {
				var form = _ref3.form;
				return { form: form - 1 };
			});
		}, _this.on_request_close = function (event) {
			var closeLabel = _this.props.closeLabel;
			var form = _this.state.form;

			// If the modal has an explicit "Cancel" button,
			// then allow closing it by hitting "Escape" key,
			// but don't close it on a click outside.
			// (because a user wouldn't want to loose form data due to a misclick)

			if (closeLabel && form && event && event.type !== 'keydown') {
				_this.indicate_cannot_close();
				return ReactDOM.findDOMNode(_this.content).parentNode.focus();
			}

			_this.close_if_not_busy();
		}, _this.close_if_not_busy = function () {
			var _this$props = _this.props,
			    busy = _this$props.busy,
			    close = _this$props.close,
			    closeTimeout = _this$props.closeTimeout;

			// For weird messed development mode cases

			if (_this.unmounted) {
				return;
			}

			// Don't close the modal if it's busy
			if (busy) {
				return _this.indicate_cannot_close();
			}

			// Abruptly end "couldn't close" animation to make room for closing animation
			_this.setState({ could_not_close_because_busy: false });

			// Close the modal
			if (close) {
				close();
			}
		}, _this.on_after_open = function () {
			var afterOpen = _this.props.afterOpen;


			_this.adjust_scrollbar_after_open();

			if (afterOpen) {
				afterOpen();
			}
		}, _this.on_after_close = function () {
			var _this$props2 = _this.props,
			    afterClose = _this$props2.afterClose,
			    reset = _this$props2.reset;


			if (reset) {
				reset();
			}

			if (afterClose) {
				afterClose();
			}

			_this.adjust_scrollbar_after_close();
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(Modal, [{
		key: 'getChildContext',
		value: function getChildContext() {
			var closeLabel = this.props.closeLabel;


			var context = {
				rrui__modal: {
					closeLabel: closeLabel,
					close_if_not_busy: this.close_if_not_busy,
					register_form: this.register_form,
					unregister_form: this.unregister_form
				}
			};

			return context;
		}
	}, {
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps(nextProps) {
			var _props = this.props,
			    unmount = _props.unmount,
			    isOpen = _props.isOpen;


			if (!unmount) {
				if (!isOpen && nextProps.isOpen) {
					this.on_after_open();
				} else if (isOpen && !nextProps.isOpen) {
					this.on_after_close();
					this.reset_content_scroll();
				}
			}
		}

		// A modal itself umounts only when the user leaves a page,
		// so in a "Single Page Application", for example,
		// if this was a regular popup and a user could still navigate
		// away via a hyperlink then this code becomes neccessary.

	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			var isOpen = this.props.isOpen;


			this.unmounted = true;

			// If the modal is still open
			// while a user navigates away
			// then "close" it properly
			// (restore the document scrollbars, etc).
			if (isOpen) {
				this.on_after_close();
			}

			if (this.could_not_close_because_busy_animation_timeout) {
				clearTimeout(this.could_not_close_because_busy_animation_timeout);
				this.could_not_close_because_busy_animation_timeout = undefined;
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var _props2 = this.props,
			    busy = _props2.busy,
			    fullscreen = _props2.fullscreen,
			    isOpen = _props2.isOpen,
			    closeTimeout = _props2.closeTimeout,
			    contentLabel = _props2.contentLabel,
			    title = _props2.title,
			    closeLabel = _props2.closeLabel,
			    closeButton = _props2.closeButton,
			    actions = _props2.actions,
			    unmount = _props2.unmount,
			    style = _props2.style,
			    className = _props2.className,
			    overlayClassName = _props2.overlayClassName,
			    children = _props2.children;
			var _state = this.state,
			    could_not_close_because_busy = _state.could_not_close_because_busy,
			    form = _state.form;


			var markup = React.createElement(
				ReactModal,
				{
					isOpen: unmount ? isOpen : true,
					onAfterOpen: unmount ? this.on_after_open : undefined,
					onRequestClose: this.on_request_close,
					closeTimeoutMS: closeTimeout,
					contentLabel: contentLabel,
					style: react_modal_style,
					overlayClassName: classNames('rrui__modal__overlay', {
						'rrui__modal__overlay--busy': busy,
						'rrui__modal__overlay--fullscreen': fullscreen,
						'rrui__modal__overlay--hidden': !unmount && !isOpen
					}, overlayClassName),
					className: classNames('rrui__modal__container', {
						'rrui__modal__container--fullscreen': fullscreen
					}) },
				React.createElement('div', {
					className: classNames('rrui__modal__vertical-margin', 'rrui__modal__vertical-margin--top', {
						// CSS selector performance optimization
						'rrui__modal__vertical-margin--fullscreen': fullscreen
					}),
					onClick: this.on_request_close }),
				React.createElement(
					Modal_content,
					{
						ref: function ref(_ref4) {
							return _this2.content = _ref4;
						},
						closeLabel: closeLabel,
						closeButton: closeButton,
						close: this.close_if_not_busy,
						style: style,
						className: className,
						fullscreen: fullscreen,
						could_not_close_because_busy: could_not_close_because_busy,
						form: form,
						busy: busy,
						reset: this.on_after_close },
					children
				),
				React.createElement('div', {
					className: classNames('rrui__modal__vertical-margin', 'rrui__modal__vertical-margin--bottom', {
						// CSS selector performance optimization
						'rrui__modal__vertical-margin--fullscreen': fullscreen
					}),
					onClick: this.on_request_close })
			);

			return markup;
		}
	}, {
		key: 'indicate_cannot_close',


		// Play "cannot close" animation on the modal
		value: function indicate_cannot_close() {
			var _this3 = this;

			var could_not_close_because_busy_animation_duration = this.props.could_not_close_because_busy_animation_duration;
			var could_not_close_because_busy = this.state.could_not_close_because_busy;


			if (!could_not_close_because_busy) {
				this.could_not_close_because_busy_animation_timeout = setTimeout(function () {
					_this3.could_not_close_because_busy_animation_timeout = undefined;
					_this3.setState({ could_not_close_because_busy: false });
				},
				// Give it a bit of extra time to finish the CSS animation
				could_not_close_because_busy_animation_duration * 1.1);

				this.setState({ could_not_close_because_busy: true });
			}
		}
	}, {
		key: 'reset_content_scroll',


		// If the user scrolled on a previously shown react-modal,
		// then reset that previously scrolled position.
		value: function reset_content_scroll() {
			document.querySelector('.ReactModal__Overlay').scrollTop = 0;
		}

		// Hides the main (body) scrollbar upon showing a modal
		// and also adjusts the width of all "full-width" elements
		// so that they don't expand no that the scrollbar is absent.
		//
		// This doesn't account for window resizes
		// but since my body is always `overflow: visible` (a good practice)
		// there's no difference and it should work in any scenario.
		//

	}, {
		key: 'adjust_scrollbar_after_open',
		value: function adjust_scrollbar_after_open() {
			// A dummy `<div/>` to measure
			// the difference in width
			// needed for the "full-width" elements
			// after the main (body) scrollbar is deliberately hidden.
			var div = document.createElement('div');
			div.style.position = 'fixed';
			div.style.left = 0;
			div.style.right = 0;
			document.body.appendChild(div);

			// Calculate the width of the dummy `<div/>`
			// before the main (body) scrollbar is deliberately hidden.
			var width_before = div.clientWidth;

			document.body.removeChild(div);

			// Hide the main (body) scrollbar
			// so that when a user scrolls in an open modal
			// this `scroll` event doesn't go through
			// and scroll the main page.
			document.body.style.overflow = 'hidden';

			// All "full-width" elements will need their
			// width to be adjusted by this amount
			// because of the now-hidden main (body) scrollbar

			// Calculate the width of the dummy `<div/>`
			// after the main (body) scrollbar is deliberately hidden.
			var width_adjustment = div.clientWidth - width_before;

			// "full-width" elements include `document.body`
			// and all `position: fixed` elements
			// which should be marked with this special CSS class.
			//
			// Make sure to add `.rrui__fixed-full-width` CSS class
			// to all full-width `position: fixed` elements.
			// Such elements must not be `width: 100%`
			// but rather `width: auto` or `left: 0; right: 0;`.
			//
			// Adjusts the width of all "full-width" elements
			// so that they don't expand by the width of the (now absent) scrollbar
			//
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = _getIterator(get_full_width_elements()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var element = _step.value;

					element.style.marginRight = width_adjustment + 'px';
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			this.reset_content_scroll();
		}
	}, {
		key: 'adjust_scrollbar_after_close',


		// Restores original `document` scrollbar.
		value: function adjust_scrollbar_after_close() {
			var _props3 = this.props,
			    bodyOverflowX = _props3.bodyOverflowX,
			    bodyOverflowY = _props3.bodyOverflowY;

			// All "full-width" elements will need their
			// width to be restored back to the original value
			// now that the main (body) scrollbar is being restored.

			// "full-width" elements include `document.body`
			// and all `position: fixed` elements
			// which should be marked with this special CSS class.
			// (`Array.from` is transpiled by Babel)
			//
			// Make sure to add `.rrui__fixed-full-width` CSS class
			// to all full-width `position: fixed` elements.
			// Such elements must not be `width: 100%`
			// but rather `width: auto` or `left: 0; right: 0;`.
			//
			// Adjusts the width of all "full-width" elements back to their original value
			// now that the main (body) scrollbar is being restored.
			//

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = _getIterator(get_full_width_elements()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var element = _step2.value;

					element.style.marginRight = 0;
				}

				// Restore the main (body) scrollbar.
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			document.body.style.overflowX = bodyOverflowX;
			document.body.style.overflowY = bodyOverflowY;
		}

		// Restores original `document` scrollbar
		// and resets the modal content (e.g. a form)

	}]);

	return Modal;
}(PureComponent);

Modal.propTypes = {
	// If `true` then the modal is shown
	isOpen: PropTypes.bool.isRequired,

	// Closes the modal (must set the `isOpen` flag to `false`)
	close: PropTypes.func.isRequired,

	// A time required for CSS hiding animation to complete
	// (150 milliseconds by default)
	closeTimeout: PropTypes.number.isRequired,

	// Is called after the modal is shown
	afterOpen: PropTypes.func,

	// Is called after the modal is closed
	afterClose: PropTypes.func,

	// Enters fullscreen mode
	fullscreen: PropTypes.bool,

	// Modal content
	children: PropTypes.node,

	// Resets the modal on close
	// (e.g. could reset edited form fields)
	reset: PropTypes.func,

	// "Cancel" button label.
	// If set, the modal will have a "Cancel" button.
	// (only if `<Form.Actions/>` is found in content)
	closeLabel: PropTypes.string,

	// The default `overflow-x` of the <body/>.
	// Is `auto` by default.
	bodyOverflowX: PropTypes.string.isRequired,

	// The default `overflow-x` of the <body/>.
	// Is `scroll` by default
	// (which is better than `auto`
	//  because the document width won't be jumpy
	//  while navigating the website —
	//  it will be consistent across all pages)
	bodyOverflowY: PropTypes.string.isRequired,

	// `aria-label` for the modal.
	// (is "Popup" by default)
	contentLabel: PropTypes.string.isRequired,

	// An optional close button (like a cross).
	// This is not actually a "button"
	// but instead "button contents",
	// i.e. `closeButton` will be wrapped with a `<button/>`.
	closeButton: PropTypes.node,

	// If set to `false` will prevent modal contents
	// from being unmounted when the modal is closed.
	unmount: PropTypes.bool.isRequired,

	// Internal property
	could_not_close_because_busy_animation_duration: PropTypes.number.isRequired,

	// CSS class for overlay (e.g. for fullscreen modal background color)
	overlayClassName: PropTypes.string,

	// CSS class
	className: PropTypes.string,

	// CSS style object
	style: PropTypes.object
};
Modal.defaultProps = {
	isOpen: false,

	bodyOverflowX: 'auto',
	// Prevents document width from jumping due to the
	// vertical scrollbar appearance/disappearance
	bodyOverflowY: 'scroll',

	// when changing this also change
	// your .ReactModal__Overlay and .ReactModal__Content
	// css transition times accordingly
	closeTimeout: 150, // ms

	contentLabel: 'Popup',

	// Modal contents are unmounted when the modal is closed by default
	unmount: true,

	// When changing this also change
	// `.rrui__modal--could-not-close-because-busy`
	// css transition time accordingly
	could_not_close_because_busy_animation_duration: 600 // ms
};
Modal.childContextTypes = {
	rrui__modal: PropTypes.object
};
export default Modal;

var Modal_content = function (_PureComponent2) {
	_inherits(Modal_content, _PureComponent2);

	function Modal_content() {
		_classCallCheck(this, Modal_content);

		return _possibleConstructorReturn(this, (Modal_content.__proto__ || _Object$getPrototypeOf(Modal_content)).apply(this, arguments));
	}

	_createClass(Modal_content, [{
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			var reset = this.props.reset;


			if (reset) {
				reset();
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _props4 = this.props,
			    closeLabel = _props4.closeLabel,
			    close = _props4.close,
			    fullscreen = _props4.fullscreen,
			    children = _props4.children,
			    className = _props4.className,
			    style = _props4.style,
			    form = _props4.form,
			    could_not_close_because_busy = _props4.could_not_close_because_busy;


			var markup = React.createElement(
				'div',
				{
					className: classNames('rrui__modal__content', {
						// CSS selector performance optimization
						'rrui__modal__content--fullscreen': fullscreen,

						// Strictly speaking it's not `.rrui__modal` but this CSS class name will do
						'rrui__modal--could-not-close-because-busy': could_not_close_because_busy
					}, className),
					style: style },
				React.createElement(
					'div',
					{ className: 'rrui__modal__content-body' },
					this.render_close_button(),
					children,
					closeLabel && !form && React.createElement(
						'div',
						{ className: 'rrui__form__actions' },
						React.createElement(
							Button,
							{
								className: classNames('rrui__modal__close', 'rrui__modal__close--bottom'),
								action: close },
							closeLabel
						)
					)
				)
			);

			return markup;
		}
	}, {
		key: 'render_close_button',
		value: function render_close_button() {
			var _props5 = this.props,
			    closeLabel = _props5.closeLabel,
			    closeButton = _props5.closeButton,
			    close = _props5.close,
			    busy = _props5.busy;


			if (!closeButton) {
				return;
			}

			return React.createElement(
				'button',
				{
					onClick: close,
					'aria-label': closeLabel,
					className: classNames('rrui__modal__close', 'rrui__modal__close--top', {
						'rrui__modal__close--busy': busy
					}) },
				closeButton
			);
		}
	}]);

	return Modal_content;
}(PureComponent);

var react_modal_style = {
	overlay: {
		position: 'fixed',
		left: 0,
		top: 0,
		right: 0,
		bottom: 0,
		// Will show a scrollbar in case of modal content overflowing viewport height
		overflow: 'auto'
	}
};

// "full-width" elements include `document.body`
// and all `position: fixed` elements
// which should be marked with this special CSS class.
//
// Make sure to add `.rrui__fixed-full-width` CSS class
// to all full-width `position: fixed` elements.
// Such elements must not be `width: 100%`
// but rather `width: auto` or `left: 0; right: 0;`.
//
function get_full_width_elements() {
	// (`Array.from` is transpiled by Babel)
	var full_width_elements = _Array$from(document.querySelectorAll('.rrui__fixed-full-width'));
	full_width_elements.push(document.body);
	return full_width_elements;
}
//# sourceMappingURL=Modal.js.map