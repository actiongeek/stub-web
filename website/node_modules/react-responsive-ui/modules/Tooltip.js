import _extends from 'babel-runtime/helpers/extends';
import _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';
import classNames from 'classnames';

// https://github.com/Dogfalo/materialize/blob/master/js/tooltip.js

var Tooltip = function (_PureComponent) {
	_inherits(Tooltip, _PureComponent);

	function Tooltip() {
		_classCallCheck(this, Tooltip);

		var _this = _possibleConstructorReturn(this, (Tooltip.__proto__ || _Object$getPrototypeOf(Tooltip)).call(this));

		_this.show = _this.show.bind(_this);
		_this.hide = _this.hide.bind(_this);

		_this.on_mouse_enter = _this.on_mouse_enter.bind(_this);
		_this.on_mouse_leave = _this.on_mouse_leave.bind(_this);
		_this.on_touch_start = _this.on_touch_start.bind(_this);

		_this.mobile = false;
		return _this;
	}

	_createClass(Tooltip, [{
		key: 'componentWillMount',
		value: function componentWillMount() {
			// Don't render tooltip on server side
			if (typeof document === 'undefined') {
				return;
			}

			this.tooltip = document.createElement('div');

			this.tooltip.style.display = 'none';
			this.tooltip.style.position = 'absolute';
			this.tooltip.style.left = 0;
			this.tooltip.style.top = 0;

			this.tooltip.classList.add('rrui__tooltip');

			this.tooltip.textContent = this.props.text;

			this.container().appendChild(this.tooltip);
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			// Won't throw an exception
			this.tooltip.parentNode.removeChild(this.tooltip);

			if (this.hide_timeout) {
				clearTimeout(this.hide_timeout);
				this.hide_timeout = undefined;
			}

			if (this.show_timeout) {
				clearTimeout(this.show_timeout);
				this.show_timeout = undefined;
			}
		}
	}, {
		key: 'container',
		value: function container() {
			return this.props.container && this.props.container() || document.body;
		}
	}, {
		key: 'calculate_coordinates',
		value: function calculate_coordinates() {
			var width = this.tooltip.offsetWidth;
			var height = this.tooltip.offsetHeight;

			var origin = ReactDOM.findDOMNode(this.origin);

			var origin_width = origin.offsetWidth;
			// const origin_height = origin.offsetHeight

			var _offset = offset(origin);

			var top = _offset.top - height - offset(this.container()).top;
			var left = _offset.left + origin_width / 2 - width / 2;

			return reposition_within_screen(left, top, width, height);
		}
	}, {
		key: 'show',
		value: function show() {
			// Play tooltip showing animation
			var animate = false;

			// If hiding animation is being played,
			// then cancel it, and cancel setting
			// `display` to `none` after it finishes playing.
			if (this.hide_timeout) {
				clearTimeout(this.hide_timeout);
				this.hide_timeout = undefined;

				// Abort tooltip hiding animation.
				// It will automatically return to the "showing" state.
				this.tooltip.classList.remove('rrui__tooltip--before-hide');
			}
			// Otherwise, the tooltip is hidden (or never been shown)
			else {
					this.tooltip.style.display = 'block';

					// Play tooltip showing animation
					animate = true;
				}

			var coordinates = this.calculate_coordinates();
			// console.log(coordinates)

			this.tooltip.style.left = coordinates.x + 'px';
			this.tooltip.style.top = coordinates.y + 'px';

			// Play tooltip showing animation
			// (doing it after setting position because
			//  setting position applies `display: block`)
			if (animate) {
				this.tooltip.classList.add('rrui__tooltip--after-show');
			}
		}
	}, {
		key: 'hide',
		value: function hide() {
			var _this2 = this;

			var hidingAnimationDuration = this.props.hidingAnimationDuration;

			// If already hiding, or if already hidden, then do nothing.

			if (this.hide_timeout || this.tooltip.style.display === 'none') {
				return;
			}

			// Play tooltip hiding animation
			this.tooltip.classList.add('rrui__tooltip--before-hide');

			// Set the tooltip to `display: none`
			// after its hiding animation finishes.
			this.hide_timeout = setTimeout(function () {
				_this2.hide_timeout = undefined;
				_this2.tooltip.style.display = 'none';

				_this2.tooltip.classList.remove('rrui__tooltip--before-hide');
				_this2.tooltip.classList.remove('rrui__tooltip--after-show');
			}, hidingAnimationDuration);
		}
	}, {
		key: 'on_mouse_enter',
		value: function on_mouse_enter() {
			var _this3 = this;

			// mouse enter and mouse leave events
			// are triggered on mobile devices too
			if (this.mobile) {
				return;
			}

			// Shouldn't happen, because
			// `mouse leave` event clears this timeout.
			if (this.show_timeout) {
				return;
			}

			var delay = this.props.delay;

			// Don't show the tooltip immediately
			// but rather wait for the user to
			// "mouse over" it for a short time interval.
			// (prevents false positives)

			this.show_timeout = setTimeout(function () {
				_this3.show_timeout = undefined;
				_this3.show();
			}, delay);
		}
	}, {
		key: 'on_mouse_leave',
		value: function on_mouse_leave() {
			// mouse enter and mouse leave events
			// are triggered on mobile devices too
			if (this.mobile) {
				return;
			}

			// If tooltip hasn't been shown yet,
			// then cancel showing it.
			if (this.show_timeout) {
				clearTimeout(this.show_timeout);
				this.show_timeout = undefined;
				return;
			}

			// Otherwise, the tooltip is shown, so hide it.
			this.hide();
		}
	}, {
		key: 'on_touch_start',
		value: function on_touch_start() {
			// mouse enter events won't be processed from now on
			this.mobile = true;

			this.show();
		}
	}, {
		key: 'render',
		value: function render() {
			var _this4 = this;

			// Shows tooltip on mouse over when on desktop.
			// Shows tooltip on touch when on mobile.

			var _props = this.props,
			    style = _props.style,
			    className = _props.className,
			    children = _props.children;


			var markup = React.createElement(
				'div',
				{
					ref: function ref(_ref) {
						return _this4.origin = _ref;
					},
					onMouseEnter: this.on_mouse_enter,
					onMouseLeave: this.on_mouse_leave,
					onTouchStart: this.on_touch_start,
					onTouchMove: this.hide,
					onTouchEnd: this.hide,
					onTouchCancel: this.hide,
					style: style ? _extends({}, hovered_element_wrapper_style, style) : hovered_element_wrapper_style,
					className: classNames('rrui__tooltip__target', className) },
				children
			);

			return markup;
		}
	}]);

	return Tooltip;
}(PureComponent);

Tooltip.propTypes = {
	// Tooltip text
	text: PropTypes.string.isRequired,

	// The delay before the tooltip is shown (in milliseconds)
	delay: PropTypes.number.isRequired,

	// The duration of the tooltip hiding animation.
	// The DOM element will retain `display: block` for this time period.
	// When changing this timeout also change `transition` time for
	// `.tooltip--after-show` and `.tooltip--before-hide` CSS classes.
	// Is `120` by default.
	hidingAnimationDuration: PropTypes.number.isRequired,

	// `container` property is optional (it's `document.body` by default)
	container: PropTypes.func
};
Tooltip.defaultProps = {
	delay: 200, // in milliseconds
	hidingAnimationDuration: 120 // in milliseconds
};
export default Tooltip;


function reposition_within_screen(x, y, width, height) {
	var minimal_margin = 4; // in pixels

	if (x < minimal_margin) {
		x = minimal_margin;
	} else if (x + width + minimal_margin > window.innerWidth) {
		x -= x + width + minimal_margin - window.innerWidth;
	}

	if (y < window.pageYOffset + minimal_margin) {
		y = window.pageYOffset + minimal_margin;
	} else if (y + height + minimal_margin > window.pageYOffset + window.innerHeight) {
		y -= y + height + minimal_margin - (window.pageYOffset + window.innerHeight);
	}

	return { x: x, y: y };
}

// http://stackoverflow.com/questions/5598743/finding-elements-position-relative-to-the-document
function offset(element) {
	var rect = element.getBoundingClientRect();

	var client_left = document.clientLeft || document.body.clientLeft || 0;
	var client_top = document.clientTop || document.body.clientTop || 0;

	var top = rect.top + window.pageYOffset - client_top;
	var left = rect.left + window.pageXOffset - client_left;

	return { top: top, left: left };
}

var hovered_element_wrapper_style = {
	display: 'inline-block'
};
//# sourceMappingURL=Tooltip.js.map