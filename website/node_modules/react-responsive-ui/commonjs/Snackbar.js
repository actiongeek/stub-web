'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Sits at the bottom of a page and displays notifications
var Snackbar = function (_PureComponent) {
	(0, _inherits3.default)(Snackbar, _PureComponent);

	function Snackbar() {
		var _ref;

		var _temp, _this, _ret;

		(0, _classCallCheck3.default)(this, Snackbar);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = Snackbar.__proto__ || (0, _getPrototypeOf2.default)(Snackbar)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
			values: []
		}, _this.next = function () {
			var values = _this.state.values;
			var _this$props = _this.props,
			    hideAnimationDuration = _this$props.hideAnimationDuration,
			    minTime = _this$props.minTime,
			    lengthTimeFactor = _this$props.lengthTimeFactor;

			// Get the next notification from the queue
			// (will be `undefined` if the queue is empty)

			var value = values.shift();

			// Reset the notification display
			_this.setState({ value: value, height: undefined, hiding: false });

			// If the queue is empty, then just exit
			if (!value) {
				return;
			}

			// `state.show` will be set to `true` later,
			// when the height of the element is measured
			// (which is after it renders)

			// Hide the notification after it expires
			_this.auto_hide_timer = setTimeout(function () {
				// Clearing memory
				_this.auto_hide_timer = undefined;

				// Start the hiding animation for the notification
				_this.setState({ show: false, hiding: true });

				// Display the next notification
				// after the currently being hidden one
				// finishes its hiding animation.
				_this.show_next_snack_timeout = setTimeout(function () {
					_this.show_next_snack_timeout = undefined;
					_this.next();
				}, hideAnimationDuration);
			},
			// The total display duration (in milliseconds) of a snack
			// is `minTime + message.length * lengthTimeFactor`
			value.duration || minTime + (typeof value.content === 'string' ? value.content.length * lengthTimeFactor : 0));
		}, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	}

	(0, _createClass3.default)(Snackbar, [{
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			if (this.auto_hide_timer) {
				clearTimeout(this.auto_hide_timer);
				this.auto_hide_timer = undefined;
			}

			if (this.show_next_snack_timeout) {
				clearTimeout(this.show_next_snack_timeout);
				this.show_next_snack_timeout = undefined;
			}

			if (this.show_snack_timeout) {
				clearTimeout(this.show_snack_timeout);
				this.show_snack_timeout = undefined;
			}
		}
	}, {
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps(new_props) {
			var value = new_props.value,
			    reset = new_props.reset;

			// Redux has an optimization built in:
			// it won't rerender a `@connect`ed component
			// if its new `props` are shallowly equal to the previous ones.
			// Therefore, manually resetting the `value` property here
			// immediately after receiving it (a non-`undefined` value)
			// so that the same notification message could later be displayed.

			if (value) {
				// Normalize value (make it a plain javascript object)
				// if it's a string or a react element.
				if (!((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object' && !value.props)) {
					value = { content: value };
				}

				// Add the notification to the queue
				this.push(value);
				// Reset the `value` property immediately
				reset();
			}
		}

		// Adds a notification to the queue

	}, {
		key: 'push',
		value: function push(new_value) {
			var _state = this.state,
			    values = _state.values,
			    value = _state.value;

			// Add the notification to the queue

			values.push(new_value);

			// If the notification queue was empty
			// then kick-start it.
			if (!value) {
				this.next();
			}
		}

		// Displays the next notification in the queue

	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate() {
			var _this2 = this;

			var _state2 = this.state,
			    height = _state2.height,
			    value = _state2.value;

			// The notification DOM element has just been rendered
			// which means its dimensions are set by now.
			// Calculate the notification container DOM element height
			// so that the slide-from-bottom animation knows
			// its target Y-position for the CSS `translate` transform.

			if (height === undefined && value) {
				(function () {
					height = _reactDom2.default.findDOMNode(_this2.snackbar).offsetHeight;
					var anti_lag_timeout = 100; // Otherwise it would jump to fully shown in Chrome when there's a queue of snacks waiting to be shown
					_this2.setState({ height: height }, function () {
						_this2.show_snack_timeout = setTimeout(function () {
							_this2.show_snack_timeout = undefined;
							_this2.setState({ show: true });
						}, anti_lag_timeout);
					});
				})();
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _this3 = this;

			var _props = this.props,
			    hideAnimationDuration = _props.hideAnimationDuration,
			    type = _props.type;
			var _state3 = this.state,
			    show = _state3.show,
			    value = _state3.value,
			    height = _state3.height,
			    hiding = _state3.hiding;


			var y = 0;

			// If no snack is being shown,
			// or if a snack is about to be shown,
			// then shift it under the screen's bottom border
			// to show the slide-from-bottom animation at the next step.
			if (!show && height !== undefined) {
				y = height + 'px';
			}

			var container_style = {
				visibility: show ? 'visible' : 'hidden',
				transform: 'translateY(' + y + ')',
				transition: 'transform ' + hideAnimationDuration + 'ms ease-out, visibility ' + hideAnimationDuration + 'ms ease-out'
			};

			if (!show && !hiding) {
				container_style.transition = 'none';
			}

			var snackbar_text_style = {
				opacity: show ? 1 : 0,
				transition: 'opacity ' + hideAnimationDuration + 'ms cubic-bezier(0.23, 1, 0.32, 1) 0ms',
				overflow: 'hidden'
			};

			var markup = _react2.default.createElement(
				'div',
				{
					style: container_style,
					className: 'rrui__snackbar__container' },
				_react2.default.createElement(
					'div',
					{
						ref: function ref(_ref2) {
							return _this3.snackbar = _ref2;
						},
						className: (0, _classnames2.default)('rrui__snackbar', value && value.type && 'rrui__snackbar--' + value.type) },
					_react2.default.createElement(
						'div',
						{
							style: snackbar_text_style,
							className: 'rrui__snackbar__text' },
						value && value.content
					)
				)
			);

			return markup;
		}
	}]);
	return Snackbar;
}(_react.PureComponent);

Snackbar.propTypes = {
	// Snackbar value (either a message, or an object)
	value: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.shape({
		content: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.string]),
		type: _propTypes2.default.string,
		duration: _propTypes2.default.number
	})]),

	// Must reset the `value`.
	reset: _propTypes2.default.func.isRequired,

	// "Snack" hiding CSS animation duration.
	// Is 400 milliseconds by default.
	hideAnimationDuration: _propTypes2.default.number.isRequired,

	// The total display duration (in milliseconds) of a snack
	// is `minTime + message.length * lengthTimeFactor`
	minTime: _propTypes2.default.number.isRequired,
	lengthTimeFactor: _propTypes2.default.number.isRequired
};
Snackbar.defaultProps = {
	hideAnimationDuration: 400,
	minTime: 1200,
	lengthTimeFactor: 60
};
exports.default = Snackbar;
//# sourceMappingURL=Snackbar.js.map