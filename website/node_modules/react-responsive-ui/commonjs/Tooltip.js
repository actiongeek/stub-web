'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://github.com/Dogfalo/materialize/blob/master/js/tooltip.js
var Tooltip = function (_PureComponent) {
	(0, _inherits3.default)(Tooltip, _PureComponent);

	function Tooltip() {
		(0, _classCallCheck3.default)(this, Tooltip);

		var _this = (0, _possibleConstructorReturn3.default)(this, (Tooltip.__proto__ || (0, _getPrototypeOf2.default)(Tooltip)).call(this));

		_this.show = _this.show.bind(_this);
		_this.hide = _this.hide.bind(_this);

		_this.on_mouse_enter = _this.on_mouse_enter.bind(_this);
		_this.on_mouse_leave = _this.on_mouse_leave.bind(_this);
		_this.on_touch_start = _this.on_touch_start.bind(_this);

		_this.mobile = false;
		return _this;
	}

	(0, _createClass3.default)(Tooltip, [{
		key: 'componentWillMount',
		value: function componentWillMount() {
			// Don't render tooltip on server side
			if (typeof document === 'undefined') {
				return;
			}

			this.tooltip = document.createElement('div');

			this.tooltip.style.display = 'none';
			this.tooltip.style.position = 'absolute';
			this.tooltip.style.left = 0;
			this.tooltip.style.top = 0;

			this.tooltip.classList.add('rrui__tooltip');

			this.tooltip.textContent = this.props.text;

			this.container().appendChild(this.tooltip);
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			// Won't throw an exception
			this.tooltip.parentNode.removeChild(this.tooltip);

			if (this.hide_timeout) {
				clearTimeout(this.hide_timeout);
				this.hide_timeout = undefined;
			}

			if (this.show_timeout) {
				clearTimeout(this.show_timeout);
				this.show_timeout = undefined;
			}
		}
	}, {
		key: 'container',
		value: function container() {
			return this.props.container && this.props.container() || document.body;
		}
	}, {
		key: 'calculate_coordinates',
		value: function calculate_coordinates() {
			var width = this.tooltip.offsetWidth;
			var height = this.tooltip.offsetHeight;

			var origin = _reactDom2.default.findDOMNode(this.origin);

			var origin_width = origin.offsetWidth;
			// const origin_height = origin.offsetHeight

			var _offset = offset(origin);

			var top = _offset.top - height - offset(this.container()).top;
			var left = _offset.left + origin_width / 2 - width / 2;

			return reposition_within_screen(left, top, width, height);
		}
	}, {
		key: 'show',
		value: function show() {
			// Play tooltip showing animation
			var animate = false;

			// If hiding animation is being played,
			// then cancel it, and cancel setting
			// `display` to `none` after it finishes playing.
			if (this.hide_timeout) {
				clearTimeout(this.hide_timeout);
				this.hide_timeout = undefined;

				// Abort tooltip hiding animation.
				// It will automatically return to the "showing" state.
				this.tooltip.classList.remove('rrui__tooltip--before-hide');
			}
			// Otherwise, the tooltip is hidden (or never been shown)
			else {
					this.tooltip.style.display = 'block';

					// Play tooltip showing animation
					animate = true;
				}

			var coordinates = this.calculate_coordinates();
			// console.log(coordinates)

			this.tooltip.style.left = coordinates.x + 'px';
			this.tooltip.style.top = coordinates.y + 'px';

			// Play tooltip showing animation
			// (doing it after setting position because
			//  setting position applies `display: block`)
			if (animate) {
				this.tooltip.classList.add('rrui__tooltip--after-show');
			}
		}
	}, {
		key: 'hide',
		value: function hide() {
			var _this2 = this;

			var hidingAnimationDuration = this.props.hidingAnimationDuration;

			// If already hiding, or if already hidden, then do nothing.

			if (this.hide_timeout || this.tooltip.style.display === 'none') {
				return;
			}

			// Play tooltip hiding animation
			this.tooltip.classList.add('rrui__tooltip--before-hide');

			// Set the tooltip to `display: none`
			// after its hiding animation finishes.
			this.hide_timeout = setTimeout(function () {
				_this2.hide_timeout = undefined;
				_this2.tooltip.style.display = 'none';

				_this2.tooltip.classList.remove('rrui__tooltip--before-hide');
				_this2.tooltip.classList.remove('rrui__tooltip--after-show');
			}, hidingAnimationDuration);
		}
	}, {
		key: 'on_mouse_enter',
		value: function on_mouse_enter() {
			var _this3 = this;

			// mouse enter and mouse leave events
			// are triggered on mobile devices too
			if (this.mobile) {
				return;
			}

			// Shouldn't happen, because
			// `mouse leave` event clears this timeout.
			if (this.show_timeout) {
				return;
			}

			var delay = this.props.delay;

			// Don't show the tooltip immediately
			// but rather wait for the user to
			// "mouse over" it for a short time interval.
			// (prevents false positives)

			this.show_timeout = setTimeout(function () {
				_this3.show_timeout = undefined;
				_this3.show();
			}, delay);
		}
	}, {
		key: 'on_mouse_leave',
		value: function on_mouse_leave() {
			// mouse enter and mouse leave events
			// are triggered on mobile devices too
			if (this.mobile) {
				return;
			}

			// If tooltip hasn't been shown yet,
			// then cancel showing it.
			if (this.show_timeout) {
				clearTimeout(this.show_timeout);
				this.show_timeout = undefined;
				return;
			}

			// Otherwise, the tooltip is shown, so hide it.
			this.hide();
		}
	}, {
		key: 'on_touch_start',
		value: function on_touch_start() {
			// mouse enter events won't be processed from now on
			this.mobile = true;

			this.show();
		}
	}, {
		key: 'render',
		value: function render() {
			var _this4 = this;

			// Shows tooltip on mouse over when on desktop.
			// Shows tooltip on touch when on mobile.

			var _props = this.props,
			    style = _props.style,
			    className = _props.className,
			    children = _props.children;


			var markup = _react2.default.createElement(
				'div',
				{
					ref: function ref(_ref) {
						return _this4.origin = _ref;
					},
					onMouseEnter: this.on_mouse_enter,
					onMouseLeave: this.on_mouse_leave,
					onTouchStart: this.on_touch_start,
					onTouchMove: this.hide,
					onTouchEnd: this.hide,
					onTouchCancel: this.hide,
					style: style ? (0, _extends3.default)({}, hovered_element_wrapper_style, style) : hovered_element_wrapper_style,
					className: (0, _classnames2.default)('rrui__tooltip__target', className) },
				children
			);

			return markup;
		}
	}]);
	return Tooltip;
}(_react.PureComponent);

Tooltip.propTypes = {
	// Tooltip text
	text: _propTypes2.default.string.isRequired,

	// The delay before the tooltip is shown (in milliseconds)
	delay: _propTypes2.default.number.isRequired,

	// The duration of the tooltip hiding animation.
	// The DOM element will retain `display: block` for this time period.
	// When changing this timeout also change `transition` time for
	// `.tooltip--after-show` and `.tooltip--before-hide` CSS classes.
	// Is `120` by default.
	hidingAnimationDuration: _propTypes2.default.number.isRequired,

	// `container` property is optional (it's `document.body` by default)
	container: _propTypes2.default.func
};
Tooltip.defaultProps = {
	delay: 200, // in milliseconds
	hidingAnimationDuration: 120 // in milliseconds
};
exports.default = Tooltip;


function reposition_within_screen(x, y, width, height) {
	var minimal_margin = 4; // in pixels

	if (x < minimal_margin) {
		x = minimal_margin;
	} else if (x + width + minimal_margin > window.innerWidth) {
		x -= x + width + minimal_margin - window.innerWidth;
	}

	if (y < window.pageYOffset + minimal_margin) {
		y = window.pageYOffset + minimal_margin;
	} else if (y + height + minimal_margin > window.pageYOffset + window.innerHeight) {
		y -= y + height + minimal_margin - (window.pageYOffset + window.innerHeight);
	}

	return { x: x, y: y };
}

// http://stackoverflow.com/questions/5598743/finding-elements-position-relative-to-the-document
function offset(element) {
	var rect = element.getBoundingClientRect();

	var client_left = document.clientLeft || document.body.clientLeft || 0;
	var client_top = document.clientTop || document.body.clientTop || 0;

	var top = rect.top + window.pageYOffset - client_top;
	var left = rect.left + window.pageXOffset - client_left;

	return { top: top, left: left };
}

var hovered_element_wrapper_style = {
	display: 'inline-block'
};
//# sourceMappingURL=Tooltip.js.map