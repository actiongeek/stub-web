'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _reactModal = require('react-modal');

var _reactModal2 = _interopRequireDefault(_reactModal);

var _Button = require('./Button');

var _Button2 = _interopRequireDefault(_Button);

var _Form = require('./Form');

var _Form2 = _interopRequireDefault(_Form);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Make sure to add `.rrui__fixed-full-width` CSS class
// to all full-width `position: fixed` elements.
// Such elements must not be `width: 100%`
// but rather `width: auto` or `left: 0; right: 0;`.
var Modal = function (_PureComponent) {
	(0, _inherits3.default)(Modal, _PureComponent);

	function Modal() {
		var _ref;

		var _temp, _this, _ret;

		(0, _classCallCheck3.default)(this, Modal);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = Modal.__proto__ || (0, _getPrototypeOf2.default)(Modal)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
			// Using a counter instead of a boolean here
			// because a new form may be mounted before the old one is unmounted.
			// (React reconciliation algorythm implementation details)
			form: 0
		}, _this.register_form = function () {
			// Using a counter instead of a boolean here
			// because a new form may be mounted before the old one is unmounted.
			// (React reconciliation algorythm implementation details)
			_this.setState(function (_ref2) {
				var form = _ref2.form;
				return { form: form + 1 };
			});
		}, _this.unregister_form = function () {
			if (_this.unmounted) {
				return;
			}

			// Using a counter instead of a boolean here
			// because a new form may be mounted before the old one is unmounted.
			// (React reconciliation algorythm implementation details)
			_this.setState(function (_ref3) {
				var form = _ref3.form;
				return { form: form - 1 };
			});
		}, _this.on_request_close = function (event) {
			var closeLabel = _this.props.closeLabel;
			var form = _this.state.form;

			// If the modal has an explicit "Cancel" button,
			// then allow closing it by hitting "Escape" key,
			// but don't close it on a click outside.
			// (because a user wouldn't want to loose form data due to a misclick)

			if (closeLabel && form && event && event.type !== 'keydown') {
				_this.indicate_cannot_close();
				return _reactDom2.default.findDOMNode(_this.content).parentNode.focus();
			}

			_this.close_if_not_busy();
		}, _this.close_if_not_busy = function () {
			var _this$props = _this.props,
			    busy = _this$props.busy,
			    close = _this$props.close,
			    closeTimeout = _this$props.closeTimeout;

			// For weird messed development mode cases

			if (_this.unmounted) {
				return;
			}

			// Don't close the modal if it's busy
			if (busy) {
				return _this.indicate_cannot_close();
			}

			// Abruptly end "couldn't close" animation to make room for closing animation
			_this.setState({ could_not_close_because_busy: false });

			// Close the modal
			if (close) {
				close();
			}
		}, _this.on_after_open = function () {
			var afterOpen = _this.props.afterOpen;


			_this.adjust_scrollbar_after_open();

			if (afterOpen) {
				afterOpen();
			}
		}, _this.on_after_close = function () {
			var _this$props2 = _this.props,
			    afterClose = _this$props2.afterClose,
			    reset = _this$props2.reset;


			if (reset) {
				reset();
			}

			if (afterClose) {
				afterClose();
			}

			_this.adjust_scrollbar_after_close();
		}, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	}

	(0, _createClass3.default)(Modal, [{
		key: 'getChildContext',
		value: function getChildContext() {
			var closeLabel = this.props.closeLabel;


			var context = {
				rrui__modal: {
					closeLabel: closeLabel,
					close_if_not_busy: this.close_if_not_busy,
					register_form: this.register_form,
					unregister_form: this.unregister_form
				}
			};

			return context;
		}
	}, {
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps(nextProps) {
			var _props = this.props,
			    unmount = _props.unmount,
			    isOpen = _props.isOpen;


			if (!unmount) {
				if (!isOpen && nextProps.isOpen) {
					this.on_after_open();
				} else if (isOpen && !nextProps.isOpen) {
					this.on_after_close();
					this.reset_content_scroll();
				}
			}
		}

		// A modal itself umounts only when the user leaves a page,
		// so in a "Single Page Application", for example,
		// if this was a regular popup and a user could still navigate
		// away via a hyperlink then this code becomes neccessary.

	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			var isOpen = this.props.isOpen;


			this.unmounted = true;

			// If the modal is still open
			// while a user navigates away
			// then "close" it properly
			// (restore the document scrollbars, etc).
			if (isOpen) {
				this.on_after_close();
			}

			if (this.could_not_close_because_busy_animation_timeout) {
				clearTimeout(this.could_not_close_because_busy_animation_timeout);
				this.could_not_close_because_busy_animation_timeout = undefined;
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var _props2 = this.props,
			    busy = _props2.busy,
			    fullscreen = _props2.fullscreen,
			    isOpen = _props2.isOpen,
			    closeTimeout = _props2.closeTimeout,
			    contentLabel = _props2.contentLabel,
			    title = _props2.title,
			    closeLabel = _props2.closeLabel,
			    closeButton = _props2.closeButton,
			    actions = _props2.actions,
			    unmount = _props2.unmount,
			    style = _props2.style,
			    className = _props2.className,
			    overlayClassName = _props2.overlayClassName,
			    children = _props2.children;
			var _state = this.state,
			    could_not_close_because_busy = _state.could_not_close_because_busy,
			    form = _state.form;


			var markup = _react2.default.createElement(
				_reactModal2.default,
				{
					isOpen: unmount ? isOpen : true,
					onAfterOpen: unmount ? this.on_after_open : undefined,
					onRequestClose: this.on_request_close,
					closeTimeoutMS: closeTimeout,
					contentLabel: contentLabel,
					style: react_modal_style,
					overlayClassName: (0, _classnames2.default)('rrui__modal__overlay', {
						'rrui__modal__overlay--busy': busy,
						'rrui__modal__overlay--fullscreen': fullscreen,
						'rrui__modal__overlay--hidden': !unmount && !isOpen
					}, overlayClassName),
					className: (0, _classnames2.default)('rrui__modal__container', {
						'rrui__modal__container--fullscreen': fullscreen
					}) },
				_react2.default.createElement('div', {
					className: (0, _classnames2.default)('rrui__modal__vertical-margin', 'rrui__modal__vertical-margin--top', {
						// CSS selector performance optimization
						'rrui__modal__vertical-margin--fullscreen': fullscreen
					}),
					onClick: this.on_request_close }),
				_react2.default.createElement(
					Modal_content,
					{
						ref: function ref(_ref4) {
							return _this2.content = _ref4;
						},
						closeLabel: closeLabel,
						closeButton: closeButton,
						close: this.close_if_not_busy,
						style: style,
						className: className,
						fullscreen: fullscreen,
						could_not_close_because_busy: could_not_close_because_busy,
						form: form,
						busy: busy,
						reset: this.on_after_close },
					children
				),
				_react2.default.createElement('div', {
					className: (0, _classnames2.default)('rrui__modal__vertical-margin', 'rrui__modal__vertical-margin--bottom', {
						// CSS selector performance optimization
						'rrui__modal__vertical-margin--fullscreen': fullscreen
					}),
					onClick: this.on_request_close })
			);

			return markup;
		}
	}, {
		key: 'indicate_cannot_close',


		// Play "cannot close" animation on the modal
		value: function indicate_cannot_close() {
			var _this3 = this;

			var could_not_close_because_busy_animation_duration = this.props.could_not_close_because_busy_animation_duration;
			var could_not_close_because_busy = this.state.could_not_close_because_busy;


			if (!could_not_close_because_busy) {
				this.could_not_close_because_busy_animation_timeout = setTimeout(function () {
					_this3.could_not_close_because_busy_animation_timeout = undefined;
					_this3.setState({ could_not_close_because_busy: false });
				},
				// Give it a bit of extra time to finish the CSS animation
				could_not_close_because_busy_animation_duration * 1.1);

				this.setState({ could_not_close_because_busy: true });
			}
		}
	}, {
		key: 'reset_content_scroll',


		// If the user scrolled on a previously shown react-modal,
		// then reset that previously scrolled position.
		value: function reset_content_scroll() {
			document.querySelector('.ReactModal__Overlay').scrollTop = 0;
		}

		// Hides the main (body) scrollbar upon showing a modal
		// and also adjusts the width of all "full-width" elements
		// so that they don't expand no that the scrollbar is absent.
		//
		// This doesn't account for window resizes
		// but since my body is always `overflow: visible` (a good practice)
		// there's no difference and it should work in any scenario.
		//

	}, {
		key: 'adjust_scrollbar_after_open',
		value: function adjust_scrollbar_after_open() {
			// A dummy `<div/>` to measure
			// the difference in width
			// needed for the "full-width" elements
			// after the main (body) scrollbar is deliberately hidden.
			var div = document.createElement('div');
			div.style.position = 'fixed';
			div.style.left = 0;
			div.style.right = 0;
			document.body.appendChild(div);

			// Calculate the width of the dummy `<div/>`
			// before the main (body) scrollbar is deliberately hidden.
			var width_before = div.clientWidth;

			document.body.removeChild(div);

			// Hide the main (body) scrollbar
			// so that when a user scrolls in an open modal
			// this `scroll` event doesn't go through
			// and scroll the main page.
			document.body.style.overflow = 'hidden';

			// All "full-width" elements will need their
			// width to be adjusted by this amount
			// because of the now-hidden main (body) scrollbar

			// Calculate the width of the dummy `<div/>`
			// after the main (body) scrollbar is deliberately hidden.
			var width_adjustment = div.clientWidth - width_before;

			// "full-width" elements include `document.body`
			// and all `position: fixed` elements
			// which should be marked with this special CSS class.
			//
			// Make sure to add `.rrui__fixed-full-width` CSS class
			// to all full-width `position: fixed` elements.
			// Such elements must not be `width: 100%`
			// but rather `width: auto` or `left: 0; right: 0;`.
			//
			// Adjusts the width of all "full-width" elements
			// so that they don't expand by the width of the (now absent) scrollbar
			//
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = (0, _getIterator3.default)(get_full_width_elements()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var element = _step.value;

					element.style.marginRight = width_adjustment + 'px';
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			this.reset_content_scroll();
		}
	}, {
		key: 'adjust_scrollbar_after_close',


		// Restores original `document` scrollbar.
		value: function adjust_scrollbar_after_close() {
			var _props3 = this.props,
			    bodyOverflowX = _props3.bodyOverflowX,
			    bodyOverflowY = _props3.bodyOverflowY;

			// All "full-width" elements will need their
			// width to be restored back to the original value
			// now that the main (body) scrollbar is being restored.

			// "full-width" elements include `document.body`
			// and all `position: fixed` elements
			// which should be marked with this special CSS class.
			// (`Array.from` is transpiled by Babel)
			//
			// Make sure to add `.rrui__fixed-full-width` CSS class
			// to all full-width `position: fixed` elements.
			// Such elements must not be `width: 100%`
			// but rather `width: auto` or `left: 0; right: 0;`.
			//
			// Adjusts the width of all "full-width" elements back to their original value
			// now that the main (body) scrollbar is being restored.
			//

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = (0, _getIterator3.default)(get_full_width_elements()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var element = _step2.value;

					element.style.marginRight = 0;
				}

				// Restore the main (body) scrollbar.
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			document.body.style.overflowX = bodyOverflowX;
			document.body.style.overflowY = bodyOverflowY;
		}

		// Restores original `document` scrollbar
		// and resets the modal content (e.g. a form)

	}]);
	return Modal;
}(_react.PureComponent);

Modal.propTypes = {
	// If `true` then the modal is shown
	isOpen: _propTypes2.default.bool.isRequired,

	// Closes the modal (must set the `isOpen` flag to `false`)
	close: _propTypes2.default.func.isRequired,

	// A time required for CSS hiding animation to complete
	// (150 milliseconds by default)
	closeTimeout: _propTypes2.default.number.isRequired,

	// Is called after the modal is shown
	afterOpen: _propTypes2.default.func,

	// Is called after the modal is closed
	afterClose: _propTypes2.default.func,

	// Enters fullscreen mode
	fullscreen: _propTypes2.default.bool,

	// Modal content
	children: _propTypes2.default.node,

	// Resets the modal on close
	// (e.g. could reset edited form fields)
	reset: _propTypes2.default.func,

	// "Cancel" button label.
	// If set, the modal will have a "Cancel" button.
	// (only if `<Form.Actions/>` is found in content)
	closeLabel: _propTypes2.default.string,

	// The default `overflow-x` of the <body/>.
	// Is `auto` by default.
	bodyOverflowX: _propTypes2.default.string.isRequired,

	// The default `overflow-x` of the <body/>.
	// Is `scroll` by default
	// (which is better than `auto`
	//  because the document width won't be jumpy
	//  while navigating the website —
	//  it will be consistent across all pages)
	bodyOverflowY: _propTypes2.default.string.isRequired,

	// `aria-label` for the modal.
	// (is "Popup" by default)
	contentLabel: _propTypes2.default.string.isRequired,

	// An optional close button (like a cross).
	// This is not actually a "button"
	// but instead "button contents",
	// i.e. `closeButton` will be wrapped with a `<button/>`.
	closeButton: _propTypes2.default.node,

	// If set to `false` will prevent modal contents
	// from being unmounted when the modal is closed.
	unmount: _propTypes2.default.bool.isRequired,

	// Internal property
	could_not_close_because_busy_animation_duration: _propTypes2.default.number.isRequired,

	// CSS class for overlay (e.g. for fullscreen modal background color)
	overlayClassName: _propTypes2.default.string,

	// CSS class
	className: _propTypes2.default.string,

	// CSS style object
	style: _propTypes2.default.object
};
Modal.defaultProps = {
	isOpen: false,

	bodyOverflowX: 'auto',
	// Prevents document width from jumping due to the
	// vertical scrollbar appearance/disappearance
	bodyOverflowY: 'scroll',

	// when changing this also change
	// your .ReactModal__Overlay and .ReactModal__Content
	// css transition times accordingly
	closeTimeout: 150, // ms

	contentLabel: 'Popup',

	// Modal contents are unmounted when the modal is closed by default
	unmount: true,

	// When changing this also change
	// `.rrui__modal--could-not-close-because-busy`
	// css transition time accordingly
	could_not_close_because_busy_animation_duration: 600 // ms
};
Modal.childContextTypes = {
	rrui__modal: _propTypes2.default.object
};
exports.default = Modal;

var Modal_content = function (_PureComponent2) {
	(0, _inherits3.default)(Modal_content, _PureComponent2);

	function Modal_content() {
		(0, _classCallCheck3.default)(this, Modal_content);
		return (0, _possibleConstructorReturn3.default)(this, (Modal_content.__proto__ || (0, _getPrototypeOf2.default)(Modal_content)).apply(this, arguments));
	}

	(0, _createClass3.default)(Modal_content, [{
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			var reset = this.props.reset;


			if (reset) {
				reset();
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _props4 = this.props,
			    closeLabel = _props4.closeLabel,
			    close = _props4.close,
			    fullscreen = _props4.fullscreen,
			    children = _props4.children,
			    className = _props4.className,
			    style = _props4.style,
			    form = _props4.form,
			    could_not_close_because_busy = _props4.could_not_close_because_busy;


			var markup = _react2.default.createElement(
				'div',
				{
					className: (0, _classnames2.default)('rrui__modal__content', {
						// CSS selector performance optimization
						'rrui__modal__content--fullscreen': fullscreen,

						// Strictly speaking it's not `.rrui__modal` but this CSS class name will do
						'rrui__modal--could-not-close-because-busy': could_not_close_because_busy
					}, className),
					style: style },
				_react2.default.createElement(
					'div',
					{ className: 'rrui__modal__content-body' },
					this.render_close_button(),
					children,
					closeLabel && !form && _react2.default.createElement(
						'div',
						{ className: 'rrui__form__actions' },
						_react2.default.createElement(
							_Button2.default,
							{
								className: (0, _classnames2.default)('rrui__modal__close', 'rrui__modal__close--bottom'),
								action: close },
							closeLabel
						)
					)
				)
			);

			return markup;
		}
	}, {
		key: 'render_close_button',
		value: function render_close_button() {
			var _props5 = this.props,
			    closeLabel = _props5.closeLabel,
			    closeButton = _props5.closeButton,
			    close = _props5.close,
			    busy = _props5.busy;


			if (!closeButton) {
				return;
			}

			return _react2.default.createElement(
				'button',
				{
					onClick: close,
					'aria-label': closeLabel,
					className: (0, _classnames2.default)('rrui__modal__close', 'rrui__modal__close--top', {
						'rrui__modal__close--busy': busy
					}) },
				closeButton
			);
		}
	}]);
	return Modal_content;
}(_react.PureComponent);

var react_modal_style = {
	overlay: {
		position: 'fixed',
		left: 0,
		top: 0,
		right: 0,
		bottom: 0,
		// Will show a scrollbar in case of modal content overflowing viewport height
		overflow: 'auto'
	}
};

// "full-width" elements include `document.body`
// and all `position: fixed` elements
// which should be marked with this special CSS class.
//
// Make sure to add `.rrui__fixed-full-width` CSS class
// to all full-width `position: fixed` elements.
// Such elements must not be `width: 100%`
// but rather `width: auto` or `left: 0; right: 0;`.
//
function get_full_width_elements() {
	// (`Array.from` is transpiled by Babel)
	var full_width_elements = (0, _from2.default)(document.querySelectorAll('.rrui__fixed-full-width'));
	full_width_elements.push(document.body);
	return full_width_elements;
}
//# sourceMappingURL=Modal.js.map